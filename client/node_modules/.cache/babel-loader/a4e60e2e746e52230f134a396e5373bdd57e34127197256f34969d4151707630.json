{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState } from 'react';\nimport { deleteRecentSearchById, fetchRecentSearches } from \"../utils/searchHandler\";\nconst useSearch = (setMarkers, setAllMarkers, type, setLastSearch, setRecentSearches, setCenter) => {\n  _s();\n  // Added loading state for skeletons\n  const [loading, setLoading] = useState(false);\n  const fetchPlaces = async location => {\n    setLoading(true);\n    try {\n      const res = await fetch(`/api/places?location=${location.lat},${location.lng}&type=${type}&radius=5000`);\n      const data = await res.json();\n      setMarkers(data.results || []);\n      setAllMarkers(data.results || []);\n      setRecentSearches(await fetchRecentSearches());\n    } catch (error) {\n      console.error(\"❌ Error fetching places:\", error);\n    } finally {\n      setLoading(false);\n    }\n  };\n  const fetchPlaceDetails = (placeId, location, index) => {\n    const svc = new window.google.maps.places.PlacesService(map);\n    svc.getDetails({\n      placeId,\n      fields: [\"name\", \"geometry\", \"vicinity\", \"formatted_phone_number\", \"rating\", \"opening_hours\"]\n    }, (result, status) => {\n      if (status === window.google.maps.places.PlacesServiceStatus.OK) {\n        setSelectedPlace(result);\n        setCenter(location);\n        setActiveResultIndex(index);\n      }\n    });\n  };\n  const handleRefetchSearch = async (searchType, location) => {\n    setLoading(true);\n    try {\n      await fetchPlaces({\n        lat: location.coords.lat,\n        lng: location.coords.lng\n      });\n    } finally {\n      setLoading(false);\n    }\n  };\n  const handlePlaceChanged = (searchBox, selectedType) => {\n    if (!searchBox) return;\n    const place = searchBox.getPlace();\n    if (!place || !place.geometry || !place.geometry.location) return;\n    const location = {\n      lat: place.geometry.location.lat(),\n      lng: place.geometry.location.lng()\n    };\n    setCenter(location);\n    setLastSearch(place.formatted_address);\n    localStorage.setItem(\"lastSearch\", place.formatted_address);\n    fetchPlaces(location);\n  };\n  const deleteRecentSearch = async id => {\n    try {\n      await deleteRecentSearchById(id);\n      const updated = await fetchRecentSearches();\n      setRecentSearches(updated);\n    } catch (err) {\n      console.error(\"❌ Error deleting recent search:\", err);\n    }\n  };\n  const refreshRecentSearches = async () => {\n    try {\n      const updated = await fetchRecentSearches();\n      setRecentSearches(updated);\n    } catch (err) {\n      console.error(\"❌ Failed to refresh recent searches:\", err);\n    }\n  };\n  return {\n    fetchPlaces,\n    fetchPlacesDetails,\n    handleRefetchSearch,\n    handlePlaceChanged,\n    deleteRecentSearch,\n    refreshRecentSearches,\n    loading\n  };\n};\n_s(useSearch, \"/Rjh5rPqCCqf0XYnTUk9ZNavw3Q=\");\nexport default useSearch;","map":{"version":3,"names":["useState","deleteRecentSearchById","fetchRecentSearches","useSearch","setMarkers","setAllMarkers","type","setLastSearch","setRecentSearches","setCenter","_s","loading","setLoading","fetchPlaces","location","res","fetch","lat","lng","data","json","results","error","console","fetchPlaceDetails","placeId","index","svc","window","google","maps","places","PlacesService","map","getDetails","fields","result","status","PlacesServiceStatus","OK","setSelectedPlace","setActiveResultIndex","handleRefetchSearch","searchType","coords","handlePlaceChanged","searchBox","selectedType","place","getPlace","geometry","formatted_address","localStorage","setItem","deleteRecentSearch","id","updated","err","refreshRecentSearches","fetchPlacesDetails"],"sources":["/home/eashr/pet-resources-app/client/src/hooks/useSearch.jsx"],"sourcesContent":["import { useState } from 'react';\nimport { deleteRecentSearchById, fetchRecentSearches } from \"../utils/searchHandler\";\n\nconst useSearch = (\n  setMarkers,\n  setAllMarkers,\n  type,\n  setLastSearch,\n  setRecentSearches,\n  setCenter\n) => {\n  // Added loading state for skeletons\n  const [loading, setLoading] = useState(false);\n\n  const fetchPlaces = async (location) => {\n    setLoading(true);\n    try {\n      const res = await fetch(\n        `/api/places?location=${location.lat},${location.lng}&type=${type}&radius=5000`\n      );\n      const data = await res.json();\n      setMarkers(data.results || []);\n      setAllMarkers(data.results || []);\n      setRecentSearches(await fetchRecentSearches());\n    } catch (error) {\n      console.error(\"❌ Error fetching places:\", error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const fetchPlaceDetails = (placeId, location, index) => {\n    const svc = new window.google.maps.places.PlacesService(map);\n    svc.getDetails(\n      { placeId, fields: [\"name\",\"geometry\",\"vicinity\",\"formatted_phone_number\",\"rating\",\"opening_hours\"] },\n      (result, status) => {\n        if (status === window.google.maps.places.PlacesServiceStatus.OK) {\n          setSelectedPlace(result);\n          setCenter(location);\n          setActiveResultIndex(index);\n        }\n      }\n    );\n  };\n\n  const handleRefetchSearch = async (searchType, location) => {\n    setLoading(true);\n    try {\n      await fetchPlaces({ lat: location.coords.lat, lng: location.coords.lng });\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handlePlaceChanged = (searchBox, selectedType) => {\n    if (!searchBox) return;\n    const place = searchBox.getPlace();\n    if (!place || !place.geometry || !place.geometry.location) return;\n\n    const location = {\n      lat: place.geometry.location.lat(),\n      lng: place.geometry.location.lng(),\n    };\n\n    setCenter(location);\n    setLastSearch(place.formatted_address);\n    localStorage.setItem(\"lastSearch\", place.formatted_address);\n    fetchPlaces(location);\n  };\n\n  const deleteRecentSearch = async (id) => {\n    try {\n      await deleteRecentSearchById(id);\n      const updated = await fetchRecentSearches();\n      setRecentSearches(updated);\n    } catch (err) {\n      console.error(\"❌ Error deleting recent search:\", err);\n    }\n  };\n\n  const refreshRecentSearches = async () => {\n    try {\n      const updated = await fetchRecentSearches();\n      setRecentSearches(updated);\n    } catch (err) {\n      console.error(\"❌ Failed to refresh recent searches:\", err);\n    }\n  };\n\n  return {\n    fetchPlaces,\n    fetchPlacesDetails,\n    handleRefetchSearch,\n    handlePlaceChanged,\n    deleteRecentSearch,\n    refreshRecentSearches,\n    loading,\n  };\n};\n\nexport default useSearch;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}