{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState } from \"react\";\nimport axios from \"axios\";\nimport { saveSearchQuery, fetchRecentSearches } from \"../utils/searchHandler\";\nconst useDirections = (setMarkers, allMarkers, setRecentSearches = () => {}) => {\n  _s();\n  const [directionsRaw, setDirectionsRaw] = useState(null);\n  const [directionsParsed, setDirectionsParsed] = useState(null);\n  const [stepMarkers, setStepMarkers] = useState([]);\n  const [hoveredStep, setHoveredStep] = useState(null);\n  const clearDirections = (restoreMarkers = () => {}) => {\n    setDirectionsRaw(null);\n    setDirectionsParsed(null);\n    setStepMarkers([]);\n    setHoveredStep(null);\n    restoreMarkers();\n  };\n  const getDirections = async (origin, destination, type = \"veterinary_care\") => {\n    try {\n      const geocodeResponse = await axios.get(\"/api/directions/coordinates\", {\n        params: {\n          origin,\n          destination\n        }\n      });\n      const {\n        origin: originCoords,\n        destination: destinationCoords\n      } = geocodeResponse.data;\n      const directionsService = new window.google.maps.DirectionsService();\n      directionsService.route({\n        origin: originCoords,\n        destination: destinationCoords,\n        travelMode: window.google.maps.TravelMode.DRIVING\n      }, async (result, status) => {\n        if (status === \"OK\") {\n          setDirectionsRaw(result);\n          const parsed = {\n            legs: result.routes[0].legs.map(leg => ({\n              startAddress: leg.start_address,\n              endAddress: leg.end_address,\n              distance: leg.distance.text,\n              duration: leg.duration.text,\n              steps: leg.steps.map(step => step.instructions.replace(/<[^>]*>/g, \"\"))\n            }))\n          };\n          setDirectionsParsed(parsed);\n          const routeSteps = result.routes[0].legs[0].steps.map(step => ({\n            lat: step.start_location.lat(),\n            lng: step.start_location.lng()\n          }));\n          setStepMarkers(routeSteps);\n          if (setRecentSearches) {\n            setRecentSearches(await fetchRecentSearches());\n          }\n          const location = {\n            origin: originCoords,\n            destination: destinationCoords,\n            string: {\n              from: origin,\n              to: destination\n            }\n          };\n          await saveSearchQuery(type, result.routes[0].legs, location, window.location.href, origin, destination);\n        } else {\n          console.error(\"❌ Google Maps routing failed:\", status);\n        }\n      });\n    } catch (error) {\n      console.error(\"❌ Error in getDirections:\", error);\n    }\n  };\n  return {\n    directionsRaw,\n    setDirectionsRaw,\n    directionsParsed,\n    setDirectionsParsed,\n    stepMarkers,\n    setStepMarkers,\n    hoveredStep,\n    setHoveredStep,\n    clearDirections,\n    getDirections\n  };\n};\n_s(useDirections, \"b8xLdB2n4/iwGroU/L+NvDNic5g=\");\nexport default useDirections;","map":{"version":3,"names":["useState","axios","saveSearchQuery","fetchRecentSearches","useDirections","setMarkers","allMarkers","setRecentSearches","_s","directionsRaw","setDirectionsRaw","directionsParsed","setDirectionsParsed","stepMarkers","setStepMarkers","hoveredStep","setHoveredStep","clearDirections","restoreMarkers","getDirections","origin","destination","type","geocodeResponse","get","params","originCoords","destinationCoords","data","directionsService","window","google","maps","DirectionsService","route","travelMode","TravelMode","DRIVING","result","status","parsed","legs","routes","map","leg","startAddress","start_address","endAddress","end_address","distance","text","duration","steps","step","instructions","replace","routeSteps","lat","start_location","lng","location","string","from","to","href","console","error"],"sources":["/home/eashr/pet-resources-app/client/src/hooks/useDirections.jsx"],"sourcesContent":["import { useState } from \"react\";\nimport axios from \"axios\";\nimport { saveSearchQuery, fetchRecentSearches } from \"../utils/searchHandler\";\n\nconst useDirections = (\n  setMarkers,\n  allMarkers,\n  setRecentSearches = () => {}\n) => {\n  const [directionsRaw, setDirectionsRaw] = useState(null);\n  const [directionsParsed, setDirectionsParsed] = useState(null);\n  const [stepMarkers, setStepMarkers] = useState([]);\n  const [hoveredStep, setHoveredStep] = useState(null);\n\n  const clearDirections = (restoreMarkers = () => {}) => {\n    setDirectionsRaw(null);\n    setDirectionsParsed(null);\n    setStepMarkers([]);\n    setHoveredStep(null);\n    restoreMarkers();\n  };\n\n  const getDirections = async (origin, destination, type = \"veterinary_care\") => {\n    try {\n      const geocodeResponse = await axios.get(\"/api/directions/coordinates\", {\n        params: { origin, destination },\n      });\n\n      const {\n        origin: originCoords,\n        destination: destinationCoords,\n      } = geocodeResponse.data;\n\n      const directionsService = new window.google.maps.DirectionsService();\n\n      directionsService.route(\n        {\n          origin: originCoords,\n          destination: destinationCoords,\n          travelMode: window.google.maps.TravelMode.DRIVING,\n        },\n        async (result, status) => {\n          if (status === \"OK\") {\n            setDirectionsRaw(result);\n\n            const parsed = {\n              legs: result.routes[0].legs.map((leg) => ({\n                startAddress: leg.start_address,\n                endAddress: leg.end_address,\n                distance: leg.distance.text,\n                duration: leg.duration.text,\n                steps: leg.steps.map((step) =>\n                  step.instructions.replace(/<[^>]*>/g, \"\")\n                ),\n              })),\n            };\n            setDirectionsParsed(parsed);\n\n            const routeSteps = result.routes[0].legs[0].steps.map((step) => ({\n              lat: step.start_location.lat(),\n              lng: step.start_location.lng(),\n            }));\n            setStepMarkers(routeSteps);\n\n            if (setRecentSearches) {\n              setRecentSearches(await fetchRecentSearches());\n            }\n\n            const location = {\n              origin: originCoords,\n              destination: destinationCoords,\n              string: { from: origin, to: destination },\n            };\n\n            await saveSearchQuery(\n              type,\n              result.routes[0].legs,\n              location,\n              window.location.href,\n              origin,\n              destination\n            );\n          } else {\n            console.error(\"❌ Google Maps routing failed:\", status);\n          }\n        }\n      );\n    } catch (error) {\n      console.error(\"❌ Error in getDirections:\", error);\n    }\n  };\n\n  return {\n    directionsRaw,\n    setDirectionsRaw,\n    directionsParsed,\n    setDirectionsParsed,\n    stepMarkers,\n    setStepMarkers,\n    hoveredStep,\n    setHoveredStep,\n    clearDirections,\n    getDirections, \n  };\n};\n\nexport default useDirections;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}